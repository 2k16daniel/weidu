/*
Author: CamDawg

v1: for iwd fixpack v2
v2: for iwd fixpack v3, bgee fixpack development
  fixed bug with unterminated WRITE_ASCII for item icons
v3: for bgee fixpack development
  consolidated ALTER_AREA_CONTAINER_trap, cd_container_icons into new ALTER_AREA_CONTAINER
  trapped and detected were writing to the wrong offsets in ALTER_AREA_REGION
v4: for bgee fixpack development
  fixed bug with patching duration_high on item headers in ALTER_ITEM_EFFECT
v5: for bgee fixpack development
  added support for primary, secondary schools for ALTER_ITEM_HEADER
v6: final touchups for WeiDU inclusion
  renamed macros to be more in line with IESDP/WeiDU conventions
  CONVERT_BG_IWD_DURATION now converts both directions
  ALTER_AREA_ENTRANCE, ALTER_AREA_REGION now compare the target with _CASE rather than _REGEXP
  the immunity fx batch stuff shouldn't have been included
  flag_backstab and flag_noinvisible support added for ALTER_ITEM_HEADER
v7: heavy-handed editing by Wisp
  all functions follow the naming convention ALTER_FOO_BAR instead of FOO_ALTER_BAR
  exclude CONVERT_BG_IWD_DURATION, because I think it is too niche
  rename a bunch of fields for increased clarity and consistency, real or imaginary
  ALTER_*_EFFECT cannot be used to alter number or index of extended effects
  condense pairs of item/spell functions to reduce repetition and retain the old functions as shell functions
*/


/////                                                  \\\\\
///// area functions                                   \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION ALTER_AREA_ENTRANCE
  INT_VAR x_coord = "-1"  // new x coordinate at 0x20; negative values mean no change
          y_coord = "-1"  // new y coordinate at 0x22; negative values mean no change
          orient  = "-1"  // new orientation at 0x24; negative values mean no change
  STR_VAR entrance_name = "" // required, needs to match ascii name at 0x00
BEGIN

  READ_LONG  0x68 ent_off
  READ_LONG  0x6c ent_num
  FOR (index = 0 ; index < ent_num ; ++index) BEGIN
    READ_ASCII (ent_off + (index * 0x68)) ent_name (32) NULL
    PATCH_IF ("%ent_name%" STRING_COMPARE_CASE  "%entrance_name%" = 0) BEGIN
      PATCH_IF (x_coord >= 0) BEGIN WRITE_SHORT (ent_off + 0x20 + (index * 0x68)) x_coord END
      PATCH_IF (y_coord >= 0) BEGIN WRITE_SHORT (ent_off + 0x22 + (index * 0x68)) y_coord END
      PATCH_IF (orient >= 0)  BEGIN WRITE_LONG  (ent_off + 0x24 + (index * 0x68)) orient END
    END
  END

END

DEFINE_PATCH_FUNCTION ALTER_AREA_REGION
  INT_VAR type        = "-1" // region type at 0x20; negative values mean no change
          cursor      = "-1" // cursor type at 0x34; negative values mean no change
          trap_detect = "-1" // difficulty of trap detection at 0x68; negative values mean no change
          trap_remove = "-1" // difficulty of trap removal at 0x6a; negative values mean no change
          trapped     = "-1" // is trapped? at 0x6c; negative values mean no change
          detected    = "-1" // is detected? at 0x6e; negative values mean no change
          // flag_ vars affect flags starting at 0x60; 0 means remove flag, 1 means add flag, -1 no change
          flag_locked           = "-1" // locked, bit0
          flag_resets           = "-1" // trap resets, bit1
          flag_party_required   = "-1" // party required, bit2
          flag_trap_detectable  = "-1" // trap can be detected, bit3
          flag_trap_enemies     = "-1" // trap can be set off by enemies, bit4
          flag_tutorial         = "-1" // tutorial trigger, bit5
          flag_trap_npcs        = "-1" // trap can be set off by npcs, bit6
          flag_silent           = "-1" // silent trigger, bit7
          flag_deactivated      = "-1" // deactivated, bit8
          flag_impassable_npc   = "-1" // can not be passed by npcs, bit9
          flag_activation_point = "-1" // use activation point, bit10
          flag_connect_to_door  = "-1" // connected to door, bit11
  STR_VAR region_name = ""     // required, at 0x00, used to match region
          destination_area    = "same" // changes destination area at 0x38; "same" means no change
          entrance_name     = "same" // changes entrance name at 0x40; "same" means no change
          door_key     = "same" // resref of key to unlock at 0x74; "same" means no change
          door_script  = "same" // resref of region script at 0x7c; "same" means no change
BEGIN

  READ_SHORT 0x5a trig_num
  READ_LONG  0x5c trig_off
  FOR (index = 0 ; index < trig_num ; ++index) BEGIN
    READ_ASCII (trig_off + (index * 0xc4)) trig_name_file (32) NULL
    PATCH_IF ("%region_name%" STRING_COMPARE_CASE  "%trig_name_file%" = 0) BEGIN
      PATCH_IF (type >= 0)                 BEGIN WRITE_SHORT (trig_off + 0x20 + (index * 0xc4)) type        END
      PATCH_IF (cursor >= 0)               BEGIN WRITE_LONG  (trig_off + 0x34 + (index * 0xc4)) cursor      END
      PATCH_IF (trap_detect >= 0)          BEGIN WRITE_SHORT (trig_off + 0x68 + (index * 0xc4)) trap_detect END
      PATCH_IF (trap_remove >= 0)          BEGIN WRITE_SHORT (trig_off + 0x6a + (index * 0xc4)) trap_remove END
      PATCH_IF (trapped >= 0)              BEGIN WRITE_SHORT (trig_off + 0x6c + (index * 0xc4)) trapped     END
      PATCH_IF (detected >= 0)             BEGIN WRITE_SHORT (trig_off + 0x6e + (index * 0xc4)) detected    END
      PATCH_IF (flag_locked = 0)           BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b11111110) END
      PATCH_IF (flag_resets = 0)           BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b11111101) END
      PATCH_IF (flag_party_required = 0)   BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b11111011) END
      PATCH_IF (flag_trap_detectable = 0)  BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b11110111) END
      PATCH_IF (flag_trap_enemies = 0)     BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b11101111) END
      PATCH_IF (flag_tutorial = 0)         BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b11011111) END
      PATCH_IF (flag_trap_npcs = 0)        BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b10111111) END
      PATCH_IF (flag_silent = 0)           BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BAND 0b01111111) END
      PATCH_IF (flag_deactivated = 0)      BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BAND 0b11111110) END
      PATCH_IF (flag_impassable_npc = 0)   BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BAND 0b11111101) END
      PATCH_IF (flag_activation_point = 0) BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BAND 0b11111011) END
      PATCH_IF (flag_connect_to_door = 0)  BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BAND 0b11110111) END
      PATCH_IF (flag_locked = 1)           BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT0) END
      PATCH_IF (flag_resets = 1)           BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT1) END
      PATCH_IF (flag_party_required = 1)   BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT2) END
      PATCH_IF (flag_trap_detectable = 1)  BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT3) END
      PATCH_IF (flag_trap_enemies = 1)     BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT4) END
      PATCH_IF (flag_tutorial = 1)         BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT5) END
      PATCH_IF (flag_trap_npcs = 1)        BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT6) END
      PATCH_IF (flag_silent = 1)           BEGIN WRITE_BYTE  (trig_off + 0x60 + (index * 0xc4)) (THIS BOR BIT7) END
      PATCH_IF (flag_deactivated = 1)      BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BOR BIT0) END
      PATCH_IF (flag_impassable_npc = 1)   BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BOR BIT1) END
      PATCH_IF (flag_activation_point = 1) BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BOR BIT2) END
      PATCH_IF (flag_connect_to_door = 1)  BEGIN WRITE_BYTE  (trig_off + 0x61 + (index * 0xc4)) (THIS BOR BIT3) END
      PATCH_IF ("%destination_area%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (trig_off + 0x38 + (index * 0xc4)) "%destination_area%" #8
      END
      PATCH_IF ("%entrance_name%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (trig_off + 0x40 + (index * 0xc4)) "%entrance_name%" #32
      END
      PATCH_IF ("%door_key%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (trig_off + 0x74 + (index * 0xc4)) "%door_key%" #8
      END
      PATCH_IF ("%door_script%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (trig_off + 0x7c + (index * 0xc4)) "%door_script%" #8
      END
    END
  END

END

DEFINE_PATCH_FUNCTION ALTER_AREA_ACTOR
  INT_VAR x_coord = "-1" // new x coordinate at 0x20 and 0x24; negative values mean no change
          y_coord = "-1" // new y coordinate at 0x22 and 0x26; negative values mean no change
          orient  = "-1" // facing direction for actor at 0x34; negative values mean no change
  STR_VAR actor_name       = ""     // required, at 0x00, used to match actor
          dlg_file         = "same" // changes dialog file at 0x48; "same" means no change
          script_override  = "same" // changes override script at 0x50; "same" means no change
          script_general   = "same" // changes general script at 0x58; "same" means no change
          script_class     = "same" // changes class script at 0x60; "same" means no change
          script_race      = "same" // changes race script at 0x68; "same" means no change
          script_default   = "same" // changes default script at 0x70; "same" means no change
          script_specifics = "same" // changes specifics script at 0x78; "same" means no change
          cre_file         = "same" // changes creature file at 0x80; "same" means no change
BEGIN

  READ_LONG  0x54 cre_off
  READ_SHORT 0x58 cre_num
  FOR (index = 0 ; index < cre_num ; ++index) BEGIN
    READ_ASCII (cre_off + (index * 0x110)) actor_name_file (32) NULL
    PATCH_IF ("%actor_name%" STRING_COMPARE_CASE "%actor_name_file%" = 0) BEGIN
      PATCH_IF (x_coord >= 0) BEGIN WRITE_SHORT (cre_off + 0x20 + (index * 0x110)) x_coord
                                    WRITE_SHORT (cre_off + 0x24 + (index * 0x110)) x_coord END
      PATCH_IF (y_coord >= 0) BEGIN WRITE_SHORT (cre_off + 0x22 + (index * 0x110)) y_coord
                                    WRITE_SHORT (cre_off + 0x26 + (index * 0x110)) y_coord END
      PATCH_IF (orient >= 0)  BEGIN WRITE_SHORT (cre_off + 0x34 + (index * 0x110)) orient END
      PATCH_IF ("%dlg_file%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x48 + (index * 0x110)) "%dlg_file%" #8
      END
      PATCH_IF ("%script_override%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x50 + (index * 0x110)) "%script_override%" #8
      END
      PATCH_IF ("%script_general%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x58 + (index * 0x110)) "%script_general%" #8
      END
      PATCH_IF ("%script_race%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x68 + (index * 0x110)) "%script_race%" #8
      END
      PATCH_IF ("%script_default%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x70 + (index * 0x110)) "%script_default%" #8
      END
      PATCH_IF ("%script_class%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x60 + (index * 0x110)) "%script_class%" #8
      END
      PATCH_IF ("%script_specifics%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x78 + (index * 0x110)) "%script_specifics%" #8
      END
      PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cre_off + 0x80 + (index * 0x110)) "%cre_file%" #8
      END
    END
  END

END

DEFINE_PATCH_FUNCTION ALTER_AREA_CONTAINER
  INT_VAR container_type  = "-1" // container type; icon displayed when opened at 0x24; negative values mean no change
          trapped         = "-1" // is trapped? at 0x30; negative values mean no change
          detected        = "-1" // is detected? at 0x32; negative values mean no change
          lockpick_strref = "-1" // lockpick string at 0x84; negative values mean no change
          lock_difficulty = "-1" // difficulty to pick lock at 0x26; negative values mean no change
          trap_detect     = "-1" // difficulty to detect trap at 0x2c; negative values mean no change
          trap_remove     = "-1" // difficulty to remove tap at 0x2e; negative values mean no change
          // flag_ vars affect flags starting at 0x28; 0 means remove flag, 1 means add flag, -1 no change
          flag_locked     = "-1" // locked, bit0
          flag_mlocked    = "-1" // magical lock, bit2
          flag_resets     = "-1" // trap resets, bit3
          flag_disabled   = "-1" // disabled, bit5
  STR_VAR container_name  = ""   // required, at 0x00, used to match container
          container_script = "same" // changes container script at 0x48; "same" means no change
          container_key    = "same" // changes container key 0x78; "same" means no change
BEGIN

  READ_LONG  0x70 cont_off
  READ_SHORT 0x74 cont_num
  FOR (index = 0 ; index < cont_num ; ++index) BEGIN
    READ_ASCII (cont_off + (index * 0xc0)) cont_name_file (32) NULL
    PATCH_IF ("%container_name%" STRING_COMPARE_CASE "%cont_name_file%" = 0) BEGIN
      PATCH_IF (container_type  >= 0) BEGIN WRITE_SHORT (cont_off + 0x24 + (index * 0xc0)) container_type  END
      PATCH_IF (lock_difficulty >= 0) BEGIN WRITE_SHORT (cont_off + 0x26 + (index * 0xc0)) lock_difficulty END
      PATCH_IF (trap_detect     >= 0) BEGIN WRITE_SHORT (cont_off + 0x2c + (index * 0xc0)) trap_detect     END
      PATCH_IF (trap_remove     >= 0) BEGIN WRITE_SHORT (cont_off + 0x2e + (index * 0xc0)) trap_remove     END
      PATCH_IF (trapped         >= 0) BEGIN WRITE_SHORT (cont_off + 0x30 + (index * 0xc0)) trapped         END
      PATCH_IF (detected        >= 0) BEGIN WRITE_SHORT (cont_off + 0x32 + (index * 0xc0)) detected        END
      PATCH_IF (lockpick_strref >= 0) BEGIN WRITE_LONG  (cont_off + 0x84 + (index * 0xc0)) lockpick_strref END

      PATCH_IF (flag_locked   = 0) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS & `BIT0 END
      PATCH_IF (flag_mlocked  = 0) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS & `BIT2 END
      PATCH_IF (flag_resets   = 0) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS & `BIT3 END
      PATCH_IF (flag_disabled = 0) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS & `BIT5 END
      PATCH_IF (flag_locked   = 1) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS | BIT0  END
      PATCH_IF (flag_mlocked  = 1) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS | BIT2  END
      PATCH_IF (flag_resets   = 1) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS | BIT3  END
      PATCH_IF (flag_disabled = 1) BEGIN WRITE_BYTE  (cont_off + 0x28 + (index * 0xc0)) THIS | BIT5  END

      PATCH_IF ("%container_script%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cont_off + 0x48 + (index * 0xc0)) "%container_script%" #8
      END
      PATCH_IF ("%container_key%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (cont_off + 0x78 + (index * 0xc0)) "%container_key%" #8
      END
    END
  END

END

DEFINE_PATCH_FUNCTION ALTER_AREA_DOOR
  INT_VAR cursor          = "-1" // changes cursor at 0x68; negative values mean no change
          trap_detect     = "-1" // difficulty of trap detection at 0x6c; negative values mean no change
          trap_remove     = "-1" // difficulty of trap removal at 0x6e; negative values mean no change
          trapped         = "-1" // is trapped? at 0x70; negative values mean no change
          detected        = "-1" // is detected? at 0x72; negative values mean no change
          door_detect     = "-1" // difficulty of detection at 0x88; negative values mean no change
          lock_difficulty = "-1" // difficulty of lock at 0x8c; negative values mean no change
  STR_VAR door_name   = ""     // required, at 0x00, used to match door
          door_key    = "same" // changes door key at 0x78; "same" means no change
          door_script = "same" // changes door script at 0x80; "same" means no change; "same" means no change
BEGIN

  READ_LONG 0xa4 door_num
  READ_LONG 0xa8 door_off
  FOR (index = 0 ; index < door_num ; ++index) BEGIN
    READ_ASCII (door_off + (index * 0xc8)) door_name_file (32) NULL
    PATCH_IF ("%door_name%" STRING_COMPARE_CASE "%door_name_file%" = 0) BEGIN
      PATCH_IF (cursor          >= 0) BEGIN WRITE_LONG  (door_off + 0x68 + (index * 0xc8)) cursor          END
      PATCH_IF (trap_detect     >= 0) BEGIN WRITE_SHORT (door_off + 0x6c + (index * 0xc8)) trap_detect     END
      PATCH_IF (trap_remove     >= 0) BEGIN WRITE_SHORT (door_off + 0x6e + (index * 0xc8)) trap_remove     END
      PATCH_IF (trapped         >= 0) BEGIN WRITE_SHORT (door_off + 0x70 + (index * 0xc8)) trapped         END
      PATCH_IF (detected        >= 0) BEGIN WRITE_SHORT (door_off + 0x72 + (index * 0xc8)) detected        END
      PATCH_IF (door_detect     >= 0) BEGIN WRITE_LONG  (door_off + 0x88 + (index * 0xc8)) door_detect     END
      PATCH_IF (lock_difficulty >= 0) BEGIN WRITE_LONG  (door_off + 0x8c + (index * 0xc8)) lock_difficulty END

      PATCH_IF ("%door_key%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (door_off + 0x78 + (index * 0xc8)) "%door_key%" #8
      END
      PATCH_IF ("%door_script%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (door_off + 0x80 + (index * 0xc8)) "%door_script%" #8
      END
    END
  END

END

/////                                                  \\\\\
///// item functions                                   \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION ALTER_ITEM_EFFECT
  INT_VAR
    check_globals  = 0      // check global effects: 0 for no, 1 for yes
    check_headers  = 0      // check effects on headers; 0 for no, 1 for yes
    header         = 0      // add to this header; 0 for all headers
    header_type    = "-1"   // -1 to check all headers, otherwise use type specified
    match_opcode   = "-1"   // opcode at 0x00 to match, use -1 for all
    new_opcode     = "-1"   // if opcode matches, change to this value
    target         = "-1"   // change target at 0x02; negative values mean no change
    timing         = "-1"   // change timing at 0x0c; negative values mean no change
    power          = "-1"   // change power level at 0x03; negative values mean no change
    parameter1     = "-1"   // change parameter at 0x04; negative values mean no change
    parameter2     = "-1"   // change parameter at 0x08; negative values mean no change
    resist_dispel  = "-1"   // change resist/dispel at 0x0d; negative values mean no change
    duration       = "-1"   // change duration at 0x0e; negative values mean no change
    duration_high  = "-1"   // same as duration, but only if existing duration > 5
    probability1   = "-1"   // change high probability at 0x12; negative values mean no change
    probability2   = "-1"   // change low probability at 0x13; negative values mean no change
    dicenumber     = "-1"   // change number of dice at 0x1c; negative values mean no change
    dicesize       = "-1"   // change size of dice at 0x20; negative values mean no change
    savingthrow    = "-1"   // changing type of saving throw at 0x24; negative values mean no change
    savebonus      = "-11"  // change save bonus/penalty; values -11 or lower are ignored
  STR_VAR
    resource       = "same" // resref at 0x14; same means no change, otherwise use this value
BEGIN

  header_length = 0x38
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      PATCH_IF ((match_opcode = opcode_file) OR (match_opcode < 0)) BEGIN
        PATCH_IF (new_opcode >= 0)    BEGIN WRITE_SHORT (fx_off +        (index * 0x30)) new_opcode    END
        PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x02 + (index * 0x30)) target        END
        PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (fx_off + 0x03 + (index * 0x30)) power         END
        PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x04 + (index * 0x30)) parameter1    END
        PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x08 + (index * 0x30)) parameter2    END
        PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x0c + (index * 0x30)) timing        END
        PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (fx_off + 0x0d + (index * 0x30)) resist_dispel END
        PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (fx_off + 0x0e + (index * 0x30)) duration      END
        PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x12 + (index * 0x30)) probability1  END
        PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x13 + (index * 0x30)) probability2  END
        PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (fx_off + 0x1c + (index * 0x30)) dicenumber    END
        PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (fx_off + 0x20 + (index * 0x30)) dicesize      END
        PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (fx_off + 0x24 + (index * 0x30)) savingthrow   END
        PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (fx_off + 0x28 + (index * 0x30)) savebonus     END
        PATCH_IF (duration_high >= 0) BEGIN
          READ_LONG (fx_off + 0x0e + (index * 0x30)) duration_file
          PATCH_IF (duration_file > 5) BEGIN
            WRITE_LONG (fx_off + 0x0e + (index * 0x30)) duration_high
          END
        END
        PATCH_IF ("%resource%" STRING_COMPARE_CASE "same") BEGIN
          WRITE_ASCIIE (fx_off + 0x14 + (index * 0x30)) "%resource%" #8
        END
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    PATCH_IF (header = 0) BEGIN SET loop_start = 0            SET loop_end = abil_num END
                     ELSE BEGIN SET loop_start = (header - 1) SET loop_end = header   END
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      PATCH_IF ((abil_type = header_type) OR (header_type < 0)) BEGIN
        READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
        READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
        FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
          READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
          PATCH_IF ((match_opcode = opcode_file) OR (match_opcode < 0)) BEGIN
            PATCH_IF (new_opcode >= 0)    BEGIN WRITE_SHORT (fx_off +        ((index + abil_fx_idx) * 0x30)) new_opcode    END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x02 + ((index + abil_fx_idx) * 0x30)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (fx_off + 0x03 + ((index + abil_fx_idx) * 0x30)) power         END
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x04 + ((index + abil_fx_idx) * 0x30)) parameter1    END
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x08 + ((index + abil_fx_idx) * 0x30)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x0c + ((index + abil_fx_idx) * 0x30)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (fx_off + 0x0d + ((index + abil_fx_idx) * 0x30)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (fx_off + 0x0e + ((index + abil_fx_idx) * 0x30)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x12 + ((index + abil_fx_idx) * 0x30)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x13 + ((index + abil_fx_idx) * 0x30)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (fx_off + 0x1c + ((index + abil_fx_idx) * 0x30)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (fx_off + 0x20 + ((index + abil_fx_idx) * 0x30)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (fx_off + 0x24 + ((index + abil_fx_idx) * 0x30)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (fx_off + 0x28 + ((index + abil_fx_idx) * 0x30)) savebonus     END
            PATCH_IF (duration_high >= 0) BEGIN
              READ_LONG (fx_off + 0x0e + ((index + abil_fx_idx) * 0x30)) duration_file
              PATCH_IF (duration_file > 5) BEGIN
                WRITE_LONG (fx_off + 0x0e + ((index + abil_fx_idx) * 0x30)) duration_high
              END
            END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "same") BEGIN
              WRITE_ASCIIE (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) "%resource%" #8
            END
          END
        END
      END
    END
  END

END

DEFINE_PATCH_FUNCTION ALTER_ITEM_HEADER
  INT_VAR header_type        = "-1" // -1 is all headers, otherwise use value here
          match_icon         = 0    // make icon match a qualifier, 0 = no, 1 = yes
          header             = 0    // 0 matches all headers, otherwise just modify specified header - use with type = -1
          new_header_type    = "-1" // change the type at 0x00 to this value; negative values mean no change
          identify           = "-1" // identify to use? at 0x01; negative values mean no change
          location           = "-1" // ability location at 0x02; negative values mean no change
          target             = "-1" // target at 0x0c; negative values mean no change
          range              = "-1" // range at 0x0e; negative values mean no change
          launcher           = "-1" // launcher required at 0x10; negative values mean no change
          speed              = "-1" // speed at 0x12; negative values mean no change
          thac0_bonus        = "-1" // to-hit bonus at 0x14; negative values mean no change
          dicesize           = "-1" // dice size at 0x16; negative values mean no change
          primary_type       = "-1" // primary school at 0x17; negative values mean no change
          dicenumber         = "-1" // number of dice at 0x18; negative values mean no change
          secondary_type     = "-1" // seoncdary type at 0x19; negative values mean no change
          damage_bonus       = "-1" // +damage bonus at 0x1a; negative values mean no change
          damage_type        = "-1" // damage type at 0x1c; negative values mean no change
//          effects_num        = "-1" // number of effects at 0x1e; negative values mean no change
//          effects_index      = "-1" // effects index at 0x20; negative values mean no change
          charges            = "-1" // number of charges at 0x22; negative values mean no change
          drained            = "-1" // when drained? at 0x24; negative values mean no change
          projectile         = "-1" // projectile at 0x2a; negative values mean no change
          animation_overhand = "-1" // % of overhand attacks at 0x2c; negative values mean no change
          animation_backhand = "-1" // % of backhand attacks at 0x2e; negative values mean no change
          animation_thrust   = "-1" // % of thrusting attacks at 0x30; negative values mean no change
          arrow              = "-1" // is arrow? at 0x32; negative values mean no change
          bolt               = "-1" // is bolt? at 0x34; negative values mean no change
          bullet             = "-1" // is bullet? at 0x36; negative values mean no change
          // flag_ vars affect flags starting at 0x26; 0 means remove flag, 1 means add flag, -1 no change
          flag_strength      = "-1" // add strength bonus, bit0
          flag_break         = "-1" // breakable, bit1
          flag_hostile       = "-1" // hostile, bit10
          flag_recharge      = "-1" // recharge after resting, bit11
          flag_bypass        = "-1" // bypass armor, bit16
          flag_keenedge      = "-1" // keen edge, bit17
          flag_backstab      = "-1" // tobex only, can backstab, bit25
          flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26
  STR_VAR icon               = "same" // ability icon at 0x04; used to match if type > 4; same means no change otherwise use this value
BEGIN

  header_length = 0x38
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  PATCH_IF (header = 0) BEGIN SET loop_start = 0            SET loop_end = abil_num END
                   ELSE BEGIN SET loop_start = (header - 1) SET loop_end = header   END
  FOR (index = loop_start ; index < loop_end ; ++index) BEGIN
    READ_BYTE  (abil_off +        (index * header_length)) abil_type
    READ_ASCII (abil_off + 0x04 + (index * header_length)) icon_file
    PATCH_IF ((header_type < 0 AND !match_icon) OR (abil_type = header_type) OR ((match_icon = 1) AND ("%icon_file%" STRING_COMPARE_CASE "%icon%" = 0))) BEGIN
      SET ip = abil_off + (index * header_length)
      PATCH_IF (new_header_type >= 0)    BEGIN WRITE_BYTE  (ip)        new_header_type    END
      PATCH_IF (identify >= 0)           BEGIN WRITE_BYTE  (ip + 0x01) identify           END
      PATCH_IF (location >= 0)           BEGIN WRITE_BYTE  (ip + 0x02) location           END
      PATCH_IF (target >= 0)             BEGIN WRITE_BYTE  (ip + 0x0c) target             END
      PATCH_IF (range >= 0)              BEGIN WRITE_SHORT (ip + 0x0e) range              END
      PATCH_IF (launcher_or_level >= 0)  BEGIN WRITE_BYTE  (ip + 0x10) launcher_or_level  END
      PATCH_IF (speed >= 0)              BEGIN WRITE_BYTE  (ip + 0x12) speed              END
      PATCH_IF (thac0_bonus >= 0)        BEGIN WRITE_SHORT (ip + 0x14) thac0_bonus        END
      PATCH_IF (dicesize >= 0)           BEGIN WRITE_BYTE  (ip + 0x16) dicesize           END
      PATCH_IF (primary_type >= 0)       BEGIN WRITE_BYTE  (ip + 0x17) primary_type       END
      PATCH_IF (dicenumber >= 0)         BEGIN WRITE_BYTE  (ip + 0x18) dicenumber         END
      PATCH_IF (secondary_type >= 0)     BEGIN WRITE_BYTE  (ip + 0x19) secondary_type     END
      PATCH_IF (damage_bonus >= 0)       BEGIN WRITE_SHORT (ip + 0x1a) damage_bonus       END
      PATCH_IF (damage_type >= 0)        BEGIN WRITE_SHORT (ip + 0x1c) damage_type        END
   /* PATCH_IF (effects_num >= 0)        BEGIN WRITE_SHORT (ip + 0x1e) effects_num        END
      PATCH_IF (effects_index >= 0)      BEGIN WRITE_SHORT (ip + 0x20) effects_index      END */
      PATCH_IF (charges >= 0)            BEGIN WRITE_SHORT (ip + 0x22) charges            END
      PATCH_IF (drained >= 0)            BEGIN WRITE_SHORT (ip + 0x24) drained            END
      PATCH_IF (projectile >= 0)         BEGIN WRITE_SHORT (ip + 0x2a) projectile         END
      PATCH_IF (animation_overhand >= 0) BEGIN WRITE_SHORT (ip + 0x2c) animation_overhand END
      PATCH_IF (animation_backhand >= 0) BEGIN WRITE_SHORT (ip + 0x2e) animation_backhand END
      PATCH_IF (animation_thrust >= 0)   BEGIN WRITE_SHORT (ip + 0x30) animation_thrust   END
      PATCH_IF (arrow >= 0)              BEGIN WRITE_SHORT (ip + 0x32) arrow              END
      PATCH_IF (bolt >= 0)               BEGIN WRITE_SHORT (ip + 0x34) bolt               END
      PATCH_IF (bullet >= 0)             BEGIN WRITE_SHORT (ip + 0x36) bullet             END
      PATCH_IF (flag_strength = 0)       BEGIN WRITE_BYTE  (ip + 0x26) THIS & `BIT0       END
      PATCH_IF (flag_break = 0)          BEGIN WRITE_BYTE  (ip + 0x26) THIS & `BIT1       END
      PATCH_IF (flag_hostile = 0)        BEGIN WRITE_BYTE  (ip + 0x27) THIS & `BIT2       END
      PATCH_IF (flag_recharge = 0)       BEGIN WRITE_BYTE  (ip + 0x27) THIS & `BIT3       END
      PATCH_IF (flag_bypass = 0)         BEGIN WRITE_BYTE  (ip + 0x28) THIS & `BIT0       END
      PATCH_IF (flag_keenedge = 0)       BEGIN WRITE_BYTE  (ip + 0x28) THIS & `BIT1       END
      PATCH_IF (flag_backstab = 0)       BEGIN WRITE_BYTE  (ip + 0x29) THIS & `BIT1       END
      PATCH_IF (flag_noinvisible = 0)    BEGIN WRITE_BYTE  (ip + 0x29) THIS & `BIT2       END
      PATCH_IF (flag_strength = 1)       BEGIN WRITE_BYTE  (ip + 0x26) THIS | BIT0        END
      PATCH_IF (flag_break = 1)          BEGIN WRITE_BYTE  (ip + 0x26) THIS | BIT1        END
      PATCH_IF (flag_hostile = 1)        BEGIN WRITE_BYTE  (ip + 0x27) THIS | BIT2        END
      PATCH_IF (flag_recharge = 1)       BEGIN WRITE_BYTE  (ip + 0x27) THIS | BIT3        END
      PATCH_IF (flag_bypass = 1)         BEGIN WRITE_BYTE  (ip + 0x28) THIS | BIT0        END
      PATCH_IF (flag_keenedge = 1)       BEGIN WRITE_BYTE  (ip + 0x28) THIS | BIT1        END
      PATCH_IF (flag_backstab = 1)       BEGIN WRITE_BYTE  (ip + 0x29) THIS | BIT1        END
      PATCH_IF (flag_noinvisible = 1)    BEGIN WRITE_BYTE  (ip + 0x29) THIS | BIT2        END
      PATCH_IF ("%icon%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (ip + 0x04) "%icon%" #8
      END
    END
  END

END

DEFINE_PATCH_FUNCTION DELETE_ITEM_HEADER
  INT_VAR
    header_type = 0 // -1 for all headers, otherwise match type
    min_level = "-1" // -1 for all headers, otherwise match
BEGIN

  header_length = 0x38
  READ_LONG   0x64 abil_off
  READ_SHORT  0x68 abil_num
  READ_LONG   0x6a fx_off
  READ_SHORT  0x70 fx_num
  SET fx_delta = 0
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN // looks for default ability header
    READ_BYTE   (abil_off +        (index * header_length)) type_file
    READ_SHORT  (abil_off + 0x10 + (index * header_length)) min_level_file
    PATCH_IF (((header_type = type_file) OR (header_type < 0)) AND
              ((min_level = min_level_file) OR (min_level < 0))) BEGIN // default ability check
      READ_SHORT  (0x1e + abil_off + (index * header_length)) abil_fx_num
      READ_SHORT  (0x20 + abil_off + (index * header_length)) abil_fx_idx
      DELETE_BYTES (fx_off + (0x30 * (abil_fx_idx - fx_delta))) (0x30 * abil_fx_num) // deletes all associated effects
      DELETE_BYTES (abil_off + (index * header_length)) header_length                // deletes ability itself
      SET fx_delta = (fx_delta + abil_fx_num)
      SET abil_num = (abil_num - 1)
      SET index = (index - 1)
      SET fx_off = (fx_off - header_length)
    END ELSE BEGIN // if non-matched ability, need to adjust effect indices
      READ_SHORT  (0x20 + abil_off + (index * header_length)) abil_fx_idx
      WRITE_SHORT (0x20 + abil_off + (index * header_length)) (abil_fx_idx - fx_delta)
    END
  END
  WRITE_SHORT  0x68 abil_num
  WRITE_LONG   0x6a fx_off

END

/////                                                  \\\\\
///// spell functions                                  \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION ALTER_SPELL_EFFECT
  INT_VAR
    check_globals  = 0      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    header         = 0      // add to this header; 0 for all headers
    header_type    = "-1"   // -1 to check all headers, otherwise use type specified
    match_opcode   = "-1"   // opcode at 0x00 to match, use -1 for all
    new_opcode     = "-1"   // if opcode matches, change to this value
    target         = "-1"   // change target at 0x02; negative values mean no change
    timing         = "-1"   // change timing at 0x0c; negative values mean no change
    power          = "-1"   // change power level at 0x03; negative values mean no change
    parameter1     = "-1"   // change parameter at 0x04; negative values mean no change
    parameter2     = "-1"   // change parameter at 0x08; negative values mean no change
    resist_dispel  = "-1"   // change resist/dispel at 0x0d; negative values mean no change
    duration       = "-1"   // change duration at 0x0e; negative values mean no change
    duration_high  = "-1"   // same as duration, but only if existing duration > 5
    probability1   = "-1"   // change high probability at 0x12; negative values mean no change
    probability2   = "-1"   // change low probability at 0x13; negative values mean no change
    dicenumber     = "-1"   // change number of dice at 0x1c; negative values mean no change
    dicesize       = "-1"   // change size of dice at 0x20; negative values mean no change
    savingthrow    = "-1"   // changing type of saving throw at 0x24; negative values mean no change
    savebonus      = "-11"  // change save bonus/penalty; values -11 or lower are ignored
  STR_VAR
    resource       = "same" // resref at 0x14; same means no change, otherwise use this value
BEGIN

  header_length = 0x28
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      PATCH_IF ((match_opcode = opcode_file) OR (match_opcode < 0)) BEGIN
        PATCH_IF (new_opcode >= 0)    BEGIN WRITE_SHORT (fx_off +        (index * 0x30)) new_opcode    END
        PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x02 + (index * 0x30)) target        END
        PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (fx_off + 0x03 + (index * 0x30)) power         END
        PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x04 + (index * 0x30)) parameter1    END
        PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x08 + (index * 0x30)) parameter2    END
        PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x0c + (index * 0x30)) timing        END
        PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (fx_off + 0x0d + (index * 0x30)) resist_dispel END
        PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (fx_off + 0x0e + (index * 0x30)) duration      END
        PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x12 + (index * 0x30)) probability1  END
        PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x13 + (index * 0x30)) probability2  END
        PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (fx_off + 0x1c + (index * 0x30)) dicenumber    END
        PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (fx_off + 0x20 + (index * 0x30)) dicesize      END
        PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (fx_off + 0x24 + (index * 0x30)) savingthrow   END
        PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (fx_off + 0x28 + (index * 0x30)) savebonus     END
        PATCH_IF (duration_high >= 0) BEGIN
          READ_LONG (fx_off + 0x0e + (index * 0x30)) duration_file
          PATCH_IF (duration_file > 5) BEGIN
            WRITE_LONG (fx_off + 0x0e + (index * 0x30)) duration_high
          END
        END
        PATCH_IF ("%resource%" STRING_COMPARE_CASE "same") BEGIN
          WRITE_ASCIIE (fx_off + 0x14 + (index * 0x30)) "%resource%" #8
        END
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    PATCH_IF (header = 0) BEGIN SET loop_start = 0            SET loop_end = abil_num END
                     ELSE BEGIN SET loop_start = (header - 1) SET loop_end = header   END
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      PATCH_IF ((abil_type = header_type) OR (header_type < 0)) BEGIN
        READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
        READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
        FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
          READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
          PATCH_IF ((match_opcode = opcode_file) OR (match_opcode < 0)) BEGIN
            PATCH_IF (new_opcode >= 0)    BEGIN WRITE_SHORT (fx_off +        ((index + abil_fx_idx) * 0x30)) new_opcode    END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x02 + ((index + abil_fx_idx) * 0x30)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (fx_off + 0x03 + ((index + abil_fx_idx) * 0x30)) power         END
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x04 + ((index + abil_fx_idx) * 0x30)) parameter1    END
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (fx_off + 0x08 + ((index + abil_fx_idx) * 0x30)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (fx_off + 0x0c + ((index + abil_fx_idx) * 0x30)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (fx_off + 0x0d + ((index + abil_fx_idx) * 0x30)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (fx_off + 0x0e + ((index + abil_fx_idx) * 0x30)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x12 + ((index + abil_fx_idx) * 0x30)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (fx_off + 0x13 + ((index + abil_fx_idx) * 0x30)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (fx_off + 0x1c + ((index + abil_fx_idx) * 0x30)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (fx_off + 0x20 + ((index + abil_fx_idx) * 0x30)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (fx_off + 0x24 + ((index + abil_fx_idx) * 0x30)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (fx_off + 0x28 + ((index + abil_fx_idx) * 0x30)) savebonus     END
            PATCH_IF (duration_high >= 0) BEGIN
              READ_LONG (fx_off + 0x0e + ((index + abil_fx_idx) * 0x30)) duration_file
              PATCH_IF (duration_file > 5) BEGIN
                WRITE_LONG (fx_off + 0x0e + ((index + abil_fx_idx) * 0x30)) duration_high
              END
            END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "same") BEGIN
              WRITE_ASCIIE (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) "%resource%" #8
            END
          END
        END
      END
    END
  END

END

DEFINE_PATCH_FUNCTION ALTER_SPELL_HEADER
  INT_VAR header_type     = "-1" // -1 is all headers, otherwise use value here
          match_icon      = 0    // make icon match a qualifier, 0 = no, 1 = yes
          header          = 0    // 0 matches all headers, otherwise just modify specified header - use with type = -1
          new_header_type = "-1" // change the type at 0x00 to this value; negative values mean no change
          location        = "-1" // ability location at 0x02; negative values mean no change
          target          = "-1" // target at 0x0c; negative values mean no change
          range           = "-1" // range at 0x0e; negative values mean no change
          min_level       = "-1" // minimum level at 0x10; negative values mean no change
          speed           = "-1" // speed at 0x12; negative values mean no change
          thac0_bonus     = "-1" // to-hit bonus at 0x14; negative values mean no change
          dicesize        = "-1" // dice size at 0x16; negative values mean no change
          dicenumber      = "-1" // number of dice at 0x18; negative values mean no change
          damage_bonus    = "-1" // +damage bonus at 0x1a; negative values mean no change
          damage_type     = "-1" // damage type at 0x1c; negative values mean no change
//          effects_num     = "-1" // number of effects at 0x1e; negative values mean no change
//          effects_index   = "-1" // effects index at 0x20; negative values mean no change
          charges         = "-1" // number of charges at 0x22; negative values mean no change
          projectile      = "-1" // projectile at 0x26; negative values mean no change
  STR_VAR icon            = "same" // ability icon at 0x04; used to match if type > 4; same means no change otherwise use this value
BEGIN

  header_length = 0x28
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  PATCH_IF (header = 0) BEGIN SET loop_start = 0            SET loop_end = abil_num END
                   ELSE BEGIN SET loop_start = (header - 1) SET loop_end = header   END
  FOR (index = loop_start ; index < loop_end ; ++index) BEGIN
    READ_BYTE  (abil_off +        (index * header_length)) abil_type
    READ_ASCII (abil_off + 0x04 + (index * header_length)) icon_file
    PATCH_IF ((header_type < 0 AND !match_icon) OR (abil_type = header_type) OR ((match_icon = 1) AND ("%icon_file%" STRING_COMPARE_CASE "%icon%" = 0))) BEGIN
      SET ip = abil_off + (index * header_length)
      /* Some of these write lengths do not line up perfectly with the known SPL ability. Some
       * fields are bytes in the ITM ability but (presumed to be) words in the SPL ability.
       * However, legal values for the relevant fields never fall outside the byte range, so
       * we WRITE_BYTE regardless of header type. -Wisp
       */
      PATCH_IF (new_header_type >= 0)    BEGIN WRITE_BYTE  (ip)        new_header_type    END
      PATCH_IF (identify >= 0)           BEGIN WRITE_BYTE  (ip + 0x01) identify           END
      PATCH_IF (location >= 0)           BEGIN WRITE_BYTE  (ip + 0x02) location           END
      PATCH_IF (target >= 0)             BEGIN WRITE_BYTE  (ip + 0x0c) target             END
      PATCH_IF (range >= 0)              BEGIN WRITE_SHORT (ip + 0x0e) range              END
      PATCH_IF (launcher_or_level >= 0)  BEGIN WRITE_BYTE  (ip + 0x10) launcher_or_level  END
      PATCH_IF (speed >= 0)              BEGIN WRITE_BYTE  (ip + 0x12) speed              END
      PATCH_IF (thac0_bonus >= 0)        BEGIN WRITE_SHORT (ip + 0x14) thac0_bonus        END
      PATCH_IF (dicesize >= 0)           BEGIN WRITE_BYTE  (ip + 0x16) dicesize           END
      PATCH_IF (primary_type >= 0)       BEGIN WRITE_BYTE  (ip + 0x17) primary_type       END
      PATCH_IF (dicenumber >= 0)         BEGIN WRITE_BYTE  (ip + 0x18) dicenumber         END
      PATCH_IF (secondary_type >= 0)     BEGIN WRITE_BYTE  (ip + 0x19) secondary_type     END
      PATCH_IF (damage_bonus >= 0)       BEGIN WRITE_SHORT (ip + 0x1a) damage_bonus       END
      PATCH_IF (damage_type >= 0)        BEGIN WRITE_SHORT (ip + 0x1c) damage_type        END
   /* PATCH_IF (effects_num >= 0)        BEGIN WRITE_SHORT (ip + 0x1e) effects_num        END
      PATCH_IF (effects_index >= 0)      BEGIN WRITE_SHORT (ip + 0x20) effects_index      END */
      PATCH_IF (charges >= 0)            BEGIN WRITE_SHORT (ip + 0x22) charges            END
      PATCH_IF (drained >= 0)            BEGIN WRITE_SHORT (ip + 0x24) drained            END
      PATCH_IF (projectile >= 0)         BEGIN WRITE_SHORT (ip + 0x26) projectile         END
      PATCH_IF ("%icon%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE (ip + 0x04) "%icon%" #8
      END
    END
  END

END

DEFINE_PATCH_FUNCTION DELETE_SPELL_HEADER
  INT_VAR
    header_type = 0    // -1 for all headers, otherwise match type
    min_level   = "-1" // -1 for all headers, otherwise match
BEGIN

  header_length = 0x28
  READ_LONG   0x64 abil_off
  READ_SHORT  0x68 abil_num
  READ_LONG   0x6a fx_off
  READ_SHORT  0x70 fx_num
  SET fx_delta = 0
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN // looks for default ability header
    READ_BYTE   (abil_off +        (index * header_length)) type_file
    READ_SHORT  (abil_off + 0x10 + (index * header_length)) min_level_file
    PATCH_IF (((header_type = type_file) OR (header_type < 0)) AND
              ((min_level = min_level_file) OR (min_level < 0))) BEGIN // default ability check
      READ_SHORT  (0x1e + abil_off + (index * header_length)) abil_fx_num
      READ_SHORT  (0x20 + abil_off + (index * header_length)) abil_fx_idx
      DELETE_BYTES (fx_off + (0x30 * (abil_fx_idx - fx_delta))) (0x30 * abil_fx_num) // deletes all associated effects
      DELETE_BYTES (abil_off + (index * header_length)) header_length                // deletes ability itself
      SET fx_delta = (fx_delta + abil_fx_num)
      SET abil_num = (abil_num - 1)
      SET index = (index - 1)
      SET fx_off = (fx_off - header_length)
    END ELSE BEGIN // if non-matched ability, need to adjust effect indices
      READ_SHORT  (0x20 + abil_off + (index * header_length)) abil_fx_idx
      WRITE_SHORT (0x20 + abil_off + (index * header_length)) (abil_fx_idx - fx_delta)
    END
  END
  WRITE_SHORT  0x68 abil_num
  WRITE_LONG   0x6a fx_off

END

DEFINE_PATCH_FUNCTION CLONE_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-1"
          parameter2          = "-1"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          insert              = "above"

BEGIN

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      SET min_size       = 0x72
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      SET min_size       = 0x72
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      READ_LONG  0x2c4 fx_off ELSE 0
      SET counter_offset = 0x2c8
      SET abil_length = 0
      READ_BYTE 0x33 fx_type ELSE 2
      SET min_size = 0x2d4
      SET check_globals = 1
    END

    "fail"
    BEGIN
      PATCH_FAIL "ERROR: CLONE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_FAIL "ERROR: CLONE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET last = 0                              // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < (counter - last) ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0)))
          BEGIN

            // now that we've got a match, read-and-clone it:
            READ_ASCII   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) clone (0x30 + (0xd8 * fx_type))
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "below" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2 + 1) * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "first" = 0) BEGIN
              SET base = (fx_off        + (abil_fx_idx * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + counter) * (0x30 + (0xd8 * fx_type))))
            END ELSE BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))
            END
            INSERT_BYTES base (0x30 + (0xd8 * fx_type))
            WRITE_ASCIIE base "%clone%"

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END

            // update the tracking vars
            SET new_fx += 1
            SET counter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
              PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
                SET last += 1
              END ELSE BEGIN
                SET index2 += 1
              END
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx > 0)) BEGIN // fix offsets for cre files if fx inserted
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
      READ_LONG offset off
      PATCH_IF (fx_off < off) BEGIN
        WRITE_LONG offset (off + inserted)
      END
    END
  END

  PATCH_IF (new_fx = 0) BEGIN
    PATCH_WARN "WARNING: no effects added to %SOURCE_FILE%"
  END ELSE PATCH_IF (verbose) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) added"
  END

END

DEFINE_PATCH_FUNCTION DELETE_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"

BEGIN

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      SET min_size       = 0x72
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      SET min_size       = 0x72
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE " // creature effects treated like they're a single, global loop
    BEGIN
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      READ_LONG  0x2c4 fx_off ELSE 0
      SET counter_offset = 0x2c8
      SET abil_length = 0
      READ_BYTE 0x33 fx_type ELSE 2
      SET min_size = 0x2d4
      SET check_globals = 1
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: DELETE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: DELETE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // now that we've got a match, read-and-clone it:
            DELETE_BYTES   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) (0x30 + (0xd8 * fx_type))

            // update the tracking vars
            SET new_fx -= 1
            SET counter -= 1
            SET index2 -= 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx != 0)) BEGIN // fix offsets for cre files if fx deleted
    SET deleted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
      READ_LONG offset off
      PATCH_IF (fx_off < off) BEGIN
        WRITE_LONG offset (off + deleted)
      END
    END
  END

  PATCH_IF (verbose) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) deleted"
  END

END

DEFINE_PATCH_FUNCTION ALTER_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-1"
          parameter2          = "-1"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"

BEGIN

  // set variables and offsets based on the file type
  SET alter = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      SET min_size       = 0x72
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "ITM "
    BEGIN
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      SET min_size       = 0x72
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "CRE " // creature effects treated like they're a single, global loop
    BEGIN
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      READ_LONG  0x2c4 fx_off ELSE 0
      SET counter_offset = 0x2c8
      SET abil_length = 0
      READ_BYTE 0x33 fx_type ELSE 2
      SET min_size = 0x2d4
      SET check_globals = 1
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: ALTER_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: ALTER_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END

            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
    END // end loop through effects on ability
  END // end ability loop

  PATCH_IF (alter = 0) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE%"
  END

  PATCH_IF (verbose) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END
